# TXT to EPUB (青龙面板高级版)

这是一个为青龙面板深度定制的 Python 脚本，用于将 TXT 格式的小说文件批量转换为 EPUB 格式。

## ✨ 主要功能与特点

-   **青龙面板集成**：专为青龙面板设计，通过环境变量读取配置，通过 `notify.py` 发送 Bark 等通知。
-   **批量处理**：自动扫描 `INPUT_DIR` 目录下的所有 `.txt` 文件和**书籍文件夹**。
-   **智能更新**：
    -   在转换前检查 `*.txt` (源) 和 `*.epub` (目标) 的**最后修改时间 (mtime)**。
    -   如果源文件没有更新（比已生成的EPUB文件旧），将**自动跳过**，极大节省执行时间。
-   **文件夹=书 (核心功能)**：
    -   自动将 `INPUT_DIR` 下的**文件夹**识别为一本书（例如 `凡人修仙传/`）。
    -   该文件夹下的所有 `.txt` 文件会被合并为**一本EPUB**。
-   **章节更新 (核心功能)**：
    -   在合并文件夹内的 `.txt` 文件时，会按文件的**最后修改时间**排序。
    -   如果多个文件包含相同的章节标题（例如 `第一章`），脚本会**自动采用最新文件中的章节内容**，丢弃旧版本。
-   **元数据支持**：通过 `metadata.json` 文件为每本书籍（无论是文件还是文件夹）灵活配置专属的**作者**和**简介**。
-   **封面自动匹配**：自动从 `COVER_DIR` 目录查找与小说文件名（或文件夹名）同名的封面图片。
-   **高级章节解析**：
    -   支持 `〇一二两三四五六七八九十百千万亿零壹贰叁肆伍陸柒捌玖拾佰仟` 等全套中文数字。
    -   通过 `(?!\S)` 强化正则表达式，**杜绝**将正文中的 `第四节课` 误判为 `第四节` 标题。

## 🚀 青龙面板部署

#### 1\. 拉取仓库

在青龙面板的 "定时任务" -> "添加任务"，输入以下命令并执行一次，以拉取仓库：

```bash
ql repo [https://github.com/Zyone2/QingLong_txt2epub.git](https://github.com/Zyone2/QingLong_txt2epub.git)
````

#### 2\. 安装依赖

在青龙面板的 "依赖管理" -\> "Python3" 标签页中，添加以下两个依赖项并等待安装完成：

- `EbookLib>=0.18`
- `chardet>=5.0.0`

#### 3\. 配置环境变量

在青龙面板的 "环境变量" -\> "添加变量"，添加以下配置项：

| 变量名 | 是否必填 | 说明 | 默认值 |
| :--- | :--- | :--- | :--- |
| `INPUT_DIR` | **必填** | 存放 `.txt` 小说文件或**书籍文件夹**的**绝对路径**。 (例如: `/ql/data/txt/`) | |
| `OUTPUT_DIR` | **必填** | 存放生成的 `.epub` 文件的**绝对路径**。 (例如: `/ql/data/epub/`) | |
| `COVER_DIR` | 可选 | 存放封面图片的**绝对路径**。脚本将在此查找同名文件。 | |
| `METADATA_FILE_PATH` | 可选 | `metadata.json` 文件的**绝对路径**。 (见下方说明) | |
| `AUTHOR` | 可选 | 全局默认作者。如果 `metadata.json` 中未指定作者，将使用此值。 | |
| `CHAPTER_DETECTION_METHOD` | 可选 | 章节检测方法: `auto`, `pattern_only`, `double_empty_line_only`。 | `auto` |
| `ENABLE_DOUBLE_EMPTY_LINE` | 可选 | 是否启用双空行检测。 `true` 或 `false`。 | `true` |
| `ENABLE_CHAPTER_MARKER` | 可选 | 是否启用章节标记功能。 `true` 或 `false`。 | `false` |
| `CHAPTER_MARKER` | 可选 | 章节标记字符，例如 `#`, `##`, `@` 等。 | `#` |

#### 4\. (可选) 创建元数据文件 `metadata.json`

这是本脚本的核心功能。如果你想为特定书籍指定作者或简介，请：

1.  在你的服务器上（例如 `/ql/data/config/`）创建一个 `metadata.json` 文件。

2.  按照以下格式填入内容（**键** 必须与 **TXT文件名** (不含`.txt`) 或 **文件夹名** **完全一致**）：

    ```json
    {
      "斗破苍穹": {
        "author": "天蚕土豆",
        "description": "三十年河东，三十年河西，莫欺少年穷！"
      },
      "凡人修仙传": {
        "author": "忘语",
        "description": "一个普通山村小子，偶然下进入到当地江湖小门派..."
      },
      "没有简介的书": {
        "author": "某作者"
      },
      "使用全局作者的书": {
        "description": "这本书会使用你在环境变量里配置的全局 AUTHOR。"
      }
    }
    ```

3.  在青龙环境变量中设置 `METADATA_FILE_PATH`，指向这个文件的**绝对路径** (例如: `/ql/data/config/metadata.json`)。

#### 5\. 配置通知

脚本会自动调用青龙的 `notify.py` 模块。

你**不需要**在脚本里做任何事，只需要在青龙面板的 "系统设置" -\> "通知设置" 中，配置好你想要的通知方式（例如 Bark, Telegram Bot, 微信等）。脚本执行完毕后，结果会自动推送。

#### 6\. 添加定时任务

在青龙面板的 "定时任务" -\> "添加任务"，设置你的任务：

- **名称**：`批量小说转换`
- **命令**：`python3 run_qinglong.py`
- **定时**：例如 `0 3 * * *` （每天凌晨3点执行）

*(**重要**：请确保你的命令指向的是包含 `run_qinglong.py` 的那个仓库目录。如果你的仓库名是 `QingLong_txt2epub`，并且你拉取到了 `ql/data/repo/` 目录下，那么完整命令可能是 `python3 /ql/data/repo/QingLong_txt2epub/run_qinglong.py`。你可以在 "定时任务" 页面的日志中确认路径是否正确。)*

## ⚙️ 高级配置详解

#### 1\. 章节检测策略

- **Auto模式（默认）**
  - 优先使用特殊字符和模式匹配（`is_chapter_title`）。
  - 如果 `ENABLE_DOUBLE_EMPTY_LINE` 为 `true`，则将双空行作为兜底的分章方案。
- **Pattern Only模式**
  - 仅使用特殊字符和模式匹配。
  - **忽略**双空行检测，即使 `ENABLE_DOUBLE_EMPTY_LINE` 为 `true`。
- **Double Empty Line Only模式**
  - 仅使用双空行检测。
  - **忽略**所有的章节标题模式匹配（即 `第...章` 等规则会失效）。

#### 2\. 章节标记功能

- **功能说明**：当启用章节标记功能时（`ENABLE_CHAPTER_MARKER=true`），程序会在识别出章节标题后（例如 `第一章 标题`），自动在章节标题前添加指定的特殊字符（`CHAPTER_MARKER`）。
- **示例**：`第一章 标题` -\> `#第一章 标题`。这个标记会出现在最终的EPUB文件中，使章节标题更加醒目。

## 📁 项目结构

```
QingLong_txt2epub/
├── run_qinglong.py       # (核心) 青龙面板的主执行入口 (包含mtime检查、文件夹扫描逻辑)
├── QL_logger.py          # (核心) 统一日志记录器
├── metadata.json         # (配置) 用户需自行创建的元数据文件 (示例)
├── README.md             # (文档) 你正在阅读的文件
├── requirements.txt      # Python 依赖
└── src/                  # 源代码目录
    ├── __init__.py
    ├── main.py           # 包含 create_epub 和 create_epub_from_chapters 两个函数
    ├── config.py         # (核心) 环境变量配置读取
    ├── chapter_parser.py # (核心) 智能章节解析器 (包含文件夹合并逻辑)
    └── epub_builder.py   # (核心) EPUB文件构建器 (包含简介页生成)
```

## 📖 工作流程

1.  脚本启动 (`run_qinglong.py`)。

2.  读取所有环境变量，并加载 `metadata.json` (如果配置了)。

3.  扫描 `INPUT_DIR` 目录下的所有文件和文件夹。

4.  **循环处理** 每一个扫描到的项：

    -----

    **情况 A：处理文件 (`小说A.txt`)**

  1.  `book_name` 设为 `小说A`。
  2.  `output_path` 设为 `.../epub/小说A.epub`。
  3.  **[更新检查]** 检查 `小说A.txt` 的修改时间是否**晚于** `小说A.epub`。
  4.  如果否（即无需更新），**跳过**此书，计入 "Skipped" 列表。
  5.  如果是（需要更新）：
    * 查找 `小说A` 的元数据和封面。
    * 调用 `create_epub()` (该函数内部调用 `parse_chapters_from_file`)。
    * 计入 "Success" 列表。

    -----

    **情况 B：处理文件夹 (`小说B/`)**

  1.  `book_name` 设为 `小说B`。
  2.  `output_path` 设为 `.../epub/小说B.epub`。
  3.  **[更新检查]** 扫描 `小说B/` 文件夹下**所有** `.txt` 文件，找到**最新的修改时间** (latest\_mtime)。
  4.  检查 `latest_mtime` 是否**晚于** `小说B.epub`。
  5.  如果否（即无需更新），**跳过**此书，计入 "Skipped" 列表。
  6.  如果是（需要更新）：
    * 查找 `小说B` 的元数据和封面。
    * 调用 `merge_chapters_from_folder()`：
      * 按修改时间（从旧到新）读取文件夹内所有 `.txt`。
      * 解析章节，存入字典 `{"第一章": "内容"}`。
      * 后读取的文件会覆盖字典中已有的键（章节更新）。
    * 调用 `create_epub_from_chapters()`，传入合并后的章节列表。
    * 计入 "Success" 列表。

    -----

5.  所有项处理完毕后，生成一份包含 "成功"、"失败" 和 "跳过" 列表的摘要。

6.  调用青龙 `send()` 函数，将摘要发送到 Bark 等通知工具。

## 🔍 支持的章节格式

解析器 (`src/chapter_parser.py`) 支持以下格式（并已强化，防止误判）：

### 1\. 特殊字符标记 (推荐)

```
#第一章 故事开始
##第二章 情节发展
@第三章 高潮部分
```

### 2\. 数字格式 (严格匹配)

- `第1章 标题`
- `第 1 章 标题`
- `Chapter 1 标题`
- (不会匹配 `第四节课`)

### 3\. 中文数字格式 (严格匹配)

- `第一章 标题`
- `第一百章 标题`
- `第一节 标题`
- `第两千章`
- `第壹佰章`
- (不会匹配 `第四节课`)

### 4\. 其他格式

- `1. 标题`
- `1、标题`
- `一、标题`